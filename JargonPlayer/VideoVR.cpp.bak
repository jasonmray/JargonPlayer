#include "VideoVR.h"
#include "MpvCommands.h"
#include "Util.h"
#include "Jargon/StringUtilities.h"
#include "Jargon/Math/Utilities.h"

#include <algorithm>
#include <cassert>
#include <string>

#include <EGL/egl.h>
#include <GLES2/gl2.h>
#include <GLES2/gl2ext.h>

#include <sdl/include/SDL.h>

#include <libmpv/include/client.h>
#include <libmpv/include/render_gl.h>

#include <windows.h>

#pragma comment (lib, "sdl/lib/x64/sdl2.lib")
#pragma comment (lib, "libmpv/lib/x64/mpv.lib")
#pragma comment (lib, "angle/lib/x64/libGLESv2.lib")
#pragma comment (lib, "angle/lib/x64/libANGLE.lib")

#define QUOTE(...) #__VA_ARGS__

bool compileShader(GLenum type, const char* source, GLuint* shaderIdOut){
	GLuint shaderId = glCreateShader(type);
	glShaderSource(shaderId, 1, &source, NULL);
	glCompileShader(shaderId);

	GLint status;
	glGetShaderiv(shaderId, GL_COMPILE_STATUS, &status);

	if(status != GL_TRUE){
		char buffer[1024];
		glGetShaderInfoLog(shaderId, 1024, NULL, buffer);
		return false;
	}
	*shaderIdOut = shaderId;
	return true;
}

const char* VideoVR::DefaultWindowTitle = "JargonPlayer";
const int VideoVR::DefaultWindowWidth = 800;
const int VideoVR::DefaultWindowHeight = 450;

VideoVR::VideoVR():
	SdlWindow(DefaultWindowTitle, DefaultWindowWidth, DefaultWindowHeight),
	mpvEventsAvailable(true)
{
	int result = 0;

	mpv = mpv_create();
	result = mpv_initialize(mpv);
	assert(result == 0);

	static double zeroD = 0;
	static int64_t one = 1;
	static int64_t two = 2;
	static int64_t three = 3;
	static bool t = true;
	static bool f = false;

	mpv_set_option(mpv, "video-timing-offset", MPV_FORMAT_DOUBLE, &zeroD);
	mpv_set_option(mpv, "hwdec", MPV_FORMAT_FLAG, &t);
	mpv_set_option(mpv, "osc", MPV_FORMAT_FLAG, &t);
	mpv_set_option(mpv, "osd-bar", MPV_FORMAT_FLAG, &t);
	mpv_set_option(mpv, "term-osd-bar", MPV_FORMAT_FLAG, &t);
	mpv_set_option(mpv, "video-osd", MPV_FORMAT_FLAG, &t);
	{
		static double y = 0.95;
		mpv_set_option(mpv, "osd-bar-align-y", MPV_FORMAT_DOUBLE, &y);
	}
	{
		static double w = 95;
		mpv_set_option(mpv, "osd-bar-w", MPV_FORMAT_DOUBLE, &w);
	}
	mpv_set_option_string(mpv, "video-osd", "yes");
	mpv_set_option_string(mpv, "osc-visibility", "auto");
		
	mpv_set_option_string(mpv, "osd-on-seek", "msg-bar");
	mpv_set_option(mpv, "osd-level", MPV_FORMAT_INT64, &one);
	mpv_set_option_string(mpv, "player-operation-mode", "pseudo-gui");
	mpv_set_option_string(mpv, "keep-open", "yes");

	mpv_observe_property(mpv, 0, "file-format", MPV_FORMAT_STRING);
	mpv_observe_property(mpv, 0, "playlist", MPV_FORMAT_NODE);

	mpvGLParams.get_proc_address = GetProcAddress;

	mpv_render_param params[] = {
		{MPV_RENDER_PARAM_API_TYPE, (void*)MPV_RENDER_API_TYPE_OPENGL},
		{MPV_RENDER_PARAM_OPENGL_INIT_PARAMS, &mpvGLParams},
		{}
	};

	// This makes mpv use the currently set GL context. It will use the callback
	// (passed via params) to resolve GL builtin functions, as well as extensions.
	result = mpv_render_context_create(&mpvGLRenderContext, mpv, params);
	assert(result == 0);

	/////////////////////////////////
	{
		float quad[] = {-1,1, 1,1, 1,-1, -1,-1};
		GLuint vbo;
		glGenBuffers(1, &vbo);
		glBindBuffer(GL_ARRAY_BUFFER, vbo);
		glBufferData(GL_ARRAY_BUFFER, sizeof(quad), quad, GL_STATIC_DRAW);

		const char* vertexSrc = R"glsl(
			#version 150 core
			in vec2 position;

			void main()
			{
				gl_Position = vec4(position, 0.0, 1.0);
			}
		)glsl";

		GLuint vertexShader = 0;
		compileShader(GL_VERTEX_SHADER, vertexSrc, &vertexShader);

			
		const char* fragmentSrc = R"glsl(
			#version 150 core
			out vec4 outColor;

			void main()
			{
				outColor = vec4(1.0, 1.0, 1.0, 1.0);
			}
		)glsl";

		GLuint fragmentShader = 0;
		compileShader(GL_VERTEX_SHADER, fragmentSrc, &fragmentShader);

		GLuint shaderProgram = glCreateProgram();
		glAttachShader(shaderProgram, vertexShader);
		glAttachShader(shaderProgram, fragmentShader);

		glLinkProgram(shaderProgram);

		GLint posAttrib = glGetAttribLocation(shaderProgram, "position");
		glVertexAttribPointer(posAttrib, 2, GL_FLOAT, GL_FALSE, 0, 0);
		glEnableVertexAttribArray(posAttrib);

		glUseProgram(shaderProgram);

		// https://open.gl/drawing

		glGenFramebuffers(1, &fboLeft);
		glGenFramebuffers(2, &fboRight);
	}

	/////////////////////////////////////////////////////



	// We use events for thread-safe notification of the SDL main loop.
	// Generally, the wakeup callbacks (set further below) should do as least
	// work as possible, and merely wake up another thread to do actual work.
	// On SDL, waking up the mainloop is the ideal course of action. SDL's
	// SDL_PushEvent() is thread-safe, so we use that.
	wakeForMpvRedrawEventId = SDL_RegisterEvents(1);
	assert(wakeForMpvRedrawEventId >= 0);

	wakeForMpvEventsEventId = SDL_RegisterEvents(1);
	assert(wakeForMpvEventsEventId >= 0);

	// When normal mpv events are available.
	mpv_set_wakeup_callback(mpv, OnMpvEvents, this);

	// When a new frame should be drawn with mpv_opengl_cb_draw().
	// (Separate from the normal event handling mechanism for the sake of
	// users which run OpenGL on a different thread.)
	mpv_render_context_set_update_callback(mpvGLRenderContext, OnMpvRedraw, this);

	mpvEventThread = std::thread(&VideoVR::processMpvEvents, this);
	mpvEventThreadShouldExit = false;
}

VideoVR::~VideoVR(){


	mpvEventThreadShouldExit = true;
	mpvEventsAvailable.set();

	if(mpvEventThread.joinable()){
		mpvEventThread.join();
	}

	// Destroy the GL renderer and all of the GL objects it allocated. If video
	// is still running, the video track will be deselected.
	mpv_render_context_free(mpvGLRenderContext);

	mpv_destroy(mpv);
}

void VideoVR::showFormattedMessage(const char * formatString, ...){
	va_list args;
	va_start(args, formatString);
	std::string s(Jargon::StringUtilities::formatVarArgs(formatString, args));
	va_end(args);
	showMessage(s.c_str());
}

void VideoVR::showMessage(const char* msg){
	const char* cmd[] = {"show-text", msg, 0};
	mpv_command(mpv, cmd);
}

void VideoVR::startPlayAsync(const char* filename){
	const char *cmd[] = {"loadfile", filename, NULL};
	mpv_command(mpv, cmd);

	std::string baseFilename = Util::getBaseFilename(filename);
	setTitle(baseFilename.c_str());
}

void VideoVR::enqueueFile(const char* filename){
	const char *cmd[] = {"loadfile", filename, "append-play", NULL};
	mpv_command(mpv, cmd);
}

void VideoVR::playPause(){
	mpv_command(mpv, MpvCommands::TogglePlayPause);
}

void VideoVR::hideCursor(){
	SDL_Rect displayBounds = {};
	SDL_GetDisplayBounds(0, &displayBounds);
	SDL_WarpMouseGlobal(displayBounds.w, displayBounds.h / 2);
}

void VideoVR::handleEvent(SDL_Event& event){
	switch (event.type){
		case SDL_WINDOWEVENT:
		{
			if(event.window.event == SDL_WINDOWEVENT_EXPOSED){
				redraw();
			}else if(event.window.event == SDL_WINDOWEVENT_CLOSE){
				mpv_command(mpv, MpvCommands::Stop);
			}
		}
		break;
		default:
			// Happens when a new video frame should be rendered, or if the
			// current frame has to be redrawn e.g. due to OSD changes.
			if(event.type == wakeForMpvRedrawEventId){
				redraw();
			}

			// Happens when at least 1 new event is in the mpv event queue.
			if(event.type == wakeForMpvEventsEventId){
				TraceLogging::Instance()->logMpvWakeupEvent(this);

				processMpvEvents();
			}
	}

	gamepadInputHandler.handleInput(this, mpv, event);
	keyboardInputHander.handleInput(this, mpv, event);
	mouseInputHandler.handleInput(this, mpv, event);
	touchInputHandler.handleInput(this, mpv, event);

	// call superclass
	SdlWindow::handleEvent(event);
}

void VideoVR::processMpvEvents(){
	// Handle all queued mpv events.
	while (1){

		mpvEventsAvailable.wait();
		if(mpvEventThreadShouldExit){
			return;
		}

		while(1){
			mpv_event *mp_event = mpv_wait_event(mpv, 0);

			TraceLogging::Instance()->logMpvEvent(this, mp_event->event_id, mpv_event_name(mp_event->event_id));

			if(mp_event->event_id == MPV_EVENT_NONE){
				break;
			}else if(mp_event->event_id == MPV_EVENT_PLAYBACK_RESTART){
				//mpv_command(mpv, MpvCommands::ShowProgressTime);
				//mpv_command(mpv, MpvCommands::ShowProgressBar);
			}else if(mp_event->event_id == MPV_EVENT_SEEK){
				mpv_command(mpv, MpvCommands::ShowProgressTime);
				mpv_command(mpv, MpvCommands::ShowProgressBar);
			}else if(mp_event->event_id == MPV_EVENT_FILE_LOADED){
				const char* filename = mpv_get_property_string(mpv, "filename");

				bool skipImages = false;
				if(skipImages && Util::getFileExtension(filename) == "jpg"){
					mpv_command(mpv, MpvCommands::PlaylistNext);
				}else{
					setTitle(filename);
				}
			}else if(mp_event->event_id == MPV_EVENT_PROPERTY_CHANGE){
				const mpv_event_property* property = reinterpret_cast<mpv_event_property*>(mp_event->data);
				const char* propertyName = property->name;

				if(std::string("file-format") == propertyName){
					const char* fileFormat = mpv_get_property_string(mpv, "file-format");

					if(fileFormat != nullptr && std::string("mf") == fileFormat){
						//	mpv_command(mpv, MpvCommands::PlaylistNext);
					}
				}else if(std::string("playlist") == propertyName){
					const mpv_event_property* propertyData = (mpv_event_property*)mp_event->data;
					
					const mpv_node& node = *(mpv_node*)propertyData->data;
					playlistFilter.handlePlaylistChange(mpv, node);
				}
			}else if(mp_event->event_id == MPV_EVENT_SHUTDOWN){
				return;
			}
			{
				std::string msg = Jargon::StringUtilities::format("%s", mpv_event_name(mp_event->event_id));
				const char* args[] = {"show-text", msg.c_str(), 0};
				//mpv_command(mpv, args);
			}
		}
	}
}

void VideoVR::redraw(){
	int w, h;
	SDL_GetWindowSize(getSDLWindow(), &w, &h);
	mpv_opengl_fbo fboOptions = {};
	fboOptions.fbo = 0;
	fboOptions.w = w;
	fboOptions.h = h;

	static int flipY = 1;

	mpv_render_param params[] = {
		// Specify the default framebuffer (0) as target. This will
		// render onto the entire screen. If you want to show the video
		// in a smaller rectangle or apply fancy transformations, you'll
		// need to render into a separate FBO and draw it manually.
		{MPV_RENDER_PARAM_OPENGL_FBO, &fboOptions},
		// Flip rendering (needed due to flipped GL coordinate system).
		{MPV_RENDER_PARAM_FLIP_Y, &flipY},
		{}
	};

	// See render_gl.h on what OpenGL environment mpv expects, and
	// other API details.
	SDL_GL_MakeCurrent(getSDLWindow(), getGLContext());
	mpv_render_context_render(mpvGLRenderContext, params);
	SDL_GL_SwapWindow(getSDLWindow());
	mpv_render_context_report_swap(mpvGLRenderContext);
}

void *VideoVR::GetProcAddress(void *fn_ctx, const char *name){
	return SDL_GL_GetProcAddress(name);
}

void VideoVR::OnMpvEvents(void *ctx){
	((VideoVR*)ctx)->onMpvEvents();
}

void VideoVR::OnMpvRedraw(void *ctx){
	((VideoVR*)ctx)->onMpvRedraw();
}

void VideoVR::onMpvEvents(){
	SDL_Event event = {};
	event.window.windowID = getWindowId();
	event.type = wakeForMpvEventsEventId;
	SDL_PushEvent(&event);
}

void VideoVR::onMpvRedraw(){
	SDL_Event event = {};
	event.window.windowID = getWindowId();
	event.type = wakeForMpvRedrawEventId;
	SDL_PushEvent(&event);
}


int appmainvr(int argc, const char *argv[]){
	SDL_Init(SDL_INIT_VIDEO);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);

	const char* filename = argv[1];
	std::shared_ptr<VideoVR> player = std::make_shared<VideoVR>();
	player->startPlayAsync(filename);
	

	while(1){
		SDL_Event event = {};
		if(SDL_WaitEvent(&event) != 1){
			break;
		}
		if(event.type == SDL_QUIT){
			break;
		}
		if(event.type == SDL_KEYDOWN){
			if(event.key.keysym.sym == SDLK_SPACE && event.key.keysym.mod & KMOD_CTRL){
				player->playPause();
			}
		}

		player->handleEvent(event);

		if(event.type == SDL_WINDOWEVENT){
			if(event.window.event == SDL_WINDOWEVENT_CLOSE){
				player->close();
				break;
			}
		}
	}

	SDL_Quit();
	return 0;
}
